{"version":3,"sources":["module.js","menu.js","angular-panel-snap.min.js","panel-group.js","panel.js","scroll.js"],"names":["angular","module","akPanelGroupMenu","$rootScope","$log","restrict","template","scope","for","link","isDefined","panels","$on","event","data","group","stopPropagation","panel","id","name","active","push","forEach","select","$emit","error","directive","$inject","akPanelGroup","replace","controller","speed","threshold","fullWindow","keyboard","prevKey","nextKey","currentPanel","init","panelGroupController","$scope","$element","$attrs","$window","$timeout","$document","bind","ctrl","eventContainer","on","scrollFn","element","resize","keydown","e","enabled","isSnapping","which","preventDefault","snapToPanel","cancel","scrollTimeout","resizeTimeout","scrollInterval","isNaN","container","innerHeight","clientHeight","target","length","$broadcast","onLeave","scrollTarget","snapContainer","scrollTo","then","scrollOffset","onEnter","activatePanel","setActive","this","addPanel","panelScope","panelName","enableSnap","disableSnap","toggleSnap","documentElement","$watch","akPanel","require","transclude","attrs","css","width","height","position","overflow","scrollEasing","x","Math","pow","runFn","$q","cancelAnimation","requestAnimation","proto","prototype","isDocument","el","HTMLDocument","nodeType","DOCUMENT_NODE","isElement","HTMLElement","ELEMENT_NODE","unwrap","left","top","duration","aliasFn","scrollToElement","scrollToAnimated","apply","arguments","scrollLeft","scrollTop","easing","scrollAnimation","deferred","startLeft","startTop","deltaLeft","round","deltaTop","startTime","cancelOnEvents","cancelScrollAnimation","$event","unbind","reject","defer","resolve","promise","animationStep","timestamp","progress","percent","ceil","offset","getBoundingClientRect","overloaders","value","isNumber","scrollX","document","body","scrollY","overloadScrollPos","superFn","overloadFn","methodName","polyfill","vendors","fnName","fallback","key","suffix","substr","toUpperCase","i","lastTime","callback","currTime","Date","getTime","timeToCall","max","run","factory"],"mappings":"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","file":"angular-panel-snap.min.js","sourcesContent":["(function() {\n'use strict';\n\n/*\n * angular-panel-snap main module definition\n */\nangular.module('akreitals.panel-snap', []);\n\n})();\n","(function() {\n'use strict';\n\n/*\n * ak-panel-group-menu directive\n *\n * Creates a menu for the referenced ak-panel-group container\n *\n * @attribute for (required) String: name attribute of the ak-panel-group the menu is to reference\n */\nangular\n\t.module('akreitals.panel-snap')\n\t.directive('akPanelGroupMenu', akPanelGroupMenu);\n\n/* @ngInject */\nfunction akPanelGroupMenu ($rootScope, $log) {\n\treturn {\n\t\trestrict: 'EA',\n\t\ttemplate: '<ul class=\"ak-menu\"><li ng-repeat=\"panel in panels\" ng-class=\"{active: panel.active}\" ng-click=\"select(panel.id)\"><a href>{{panel.name}}</a></li></ul>',\n\t\tscope: {\n\t\t\tfor: '@'\n\t\t},\n\t\tlink: function (scope) {\n\t\t\tif (!angular.isDefined(scope.for)) {\n\t\t\t\t$log.error(\"PanelGroupMenu: no 'for' attribute provided\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tscope.panels = [];\n\n\t\t\t/*\n\t\t\t * listen for addedPanel event, if group name matches then add\n\t\t\t * it to the menu\n\t\t\t */\n\t\t\t$rootScope.$on('panelsnap:addedPanel', function (event, data) {\n\t\t\t\tif (scope.for === data.group) {\n\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\tvar panel = {\n\t\t\t\t\t\tid: data.id,\n\t\t\t\t\t\tname: data.name,\n\t\t\t\t\t\tactive: false\n\t\t\t\t\t};\n\t\t\t\t\tscope.panels.push(panel);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t/*\n\t\t\t * listen for activatePanel event, if group name matches then set\n\t\t\t * active flag target menu element\n\t\t\t */\n\t\t\t$rootScope.$on('panelsnap:activatePanel', function (event, data) {\n\t\t\t\tif (scope.for === data.group) {\n\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\tangular.forEach(scope.panels, function (panel) {\n\t\t\t\t\t\tpanel.active = false;\n\t\t\t\t\t});\n\t\t\t\t\tscope.panels[data.id].active = true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t/*\n\t\t\t * emit event to tell ak-panel-group directive to select the target panel\n\t\t\t */\n\t\t\tscope.select = function (id) {\n\t\t\t\t$rootScope.$emit('panelsnap:selectPanel', {group: scope.for, id: id});\n\t\t\t};\n\t\t}\n\t};\n}\n\n})();\n","(function() {\n'use strict';\n\n/*\n * angular-panel-snap main module definition\n */\nangular.module('akreitals.panel-snap', []);\n\n})();\n\n(function() {\n'use strict';\n\n/*\n * ak-panel-group-menu directive\n *\n * Creates a menu for the referenced ak-panel-group container\n *\n * @attribute for (required) String: name attribute of the ak-panel-group the menu is to reference\n */\nangular\n\t.module('akreitals.panel-snap')\n\t.directive('akPanelGroupMenu', akPanelGroupMenu);\n\n/* @ngInject */\nfunction akPanelGroupMenu ($rootScope, $log) {\n\treturn {\n\t\trestrict: 'EA',\n\t\ttemplate: '<ul class=\"ak-menu\"><li ng-repeat=\"panel in panels\" ng-class=\"{active: panel.active}\" ng-click=\"select(panel.id)\"><a href>{{panel.name}}</a></li></ul>',\n\t\tscope: {\n\t\t\tfor: '@'\n\t\t},\n\t\tlink: function (scope) {\n\t\t\tif (!angular.isDefined(scope.for)) {\n\t\t\t\t$log.error(\"PanelGroupMenu: no 'for' attribute provided\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tscope.panels = [];\n\n\t\t\t/*\n\t\t\t * listen for addedPanel event, if group name matches then add\n\t\t\t * it to the menu\n\t\t\t */\n\t\t\t$rootScope.$on('panelsnap:addedPanel', function (event, data) {\n\t\t\t\tif (scope.for === data.group) {\n\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\tvar panel = {\n\t\t\t\t\t\tid: data.id,\n\t\t\t\t\t\tname: data.name,\n\t\t\t\t\t\tactive: false\n\t\t\t\t\t};\n\t\t\t\t\tscope.panels.push(panel);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t/*\n\t\t\t * listen for activatePanel event, if group name matches then set\n\t\t\t * active flag target menu element\n\t\t\t */\n\t\t\t$rootScope.$on('panelsnap:activatePanel', function (event, data) {\n\t\t\t\tif (scope.for === data.group) {\n\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\tangular.forEach(scope.panels, function (panel) {\n\t\t\t\t\t\tpanel.active = false;\n\t\t\t\t\t});\n\t\t\t\t\tscope.panels[data.id].active = true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t/*\n\t\t\t * emit event to tell ak-panel-group directive to select the target panel\n\t\t\t */\n\t\t\tscope.select = function (id) {\n\t\t\t\t$rootScope.$emit('panelsnap:selectPanel', {group: scope.for, id: id});\n\t\t\t};\n\t\t}\n\t};\n}\nakPanelGroupMenu.$inject = [\"$rootScope\", \"$log\"];\n\n})();\n\n(function() {\n'use strict';\n\n/*\n * ak-panel-group directive\n *\n * Container for set of 'ak-panel' directives that maintains the panels state and all interactions with the group\n *\n * @attribute name (optional) String: name of the group, to be referenced in ak-panel-group-menu's 'for' attribute\n * @attribute speed (optional) Number: duration in milliseconds to snap to the desired panel, defaults to 400ms\n * @attribute threshold (optional) Number: amount of pixels required to scroll before snapping to the next panel, defults to 50px \n * @attribute fullWindow (optional) Boolean: true if the panels are to fill the full browser window\n * @attribute keyboard (optional) Boolean: true if key presses can be used to navigate panels\n * @attribute prevKey (optional) Number: keyCode of key to navigate to previous panel, defaults to 38 (up arrow)\n * @attribute nextKey (optional) Number: keyCode of key to navigate to next panel, defaults to 40 (down arrow)\n */\nangular\n\t.module('akreitals.panel-snap')\n\t.directive('akPanelGroup', akPanelGroup)\n\t.controller('PanelGroupController', panelGroupController);\n\n/* @ngInject */\nfunction akPanelGroup () {\n\treturn {\n\t\trestrict: 'EA',\n\t\treplace: true,\n\t\tcontroller: 'PanelGroupController',\n\t\tscope: {\n\t\t\tname: '@',\n\t\t\tspeed: '=',\n\t\t\tthreshold: '=',\n\t\t\tfullWindow: '=',\n\t\t\tkeyboard: '=',\n\t\t\tprevKey: '=',\n\t\t\tnextKey: '=',\n\t\t\tcurrentPanel: '='\n\t\t},\n\t\tlink: function (scope) {\n\t\t\t// Call init after child panels have registered with the controller\n\t\t\tscope.init();\n\t\t}\n\t};\n}\n\n/* @ngInject */\nfunction panelGroupController ($scope, $element, $attrs, $window, $timeout, $document, $rootScope) {\n\tvar ctrl = this;\n\n\tvar resizeTimeout;\n\tvar scrollTimeout;\n\n\tctrl.panels = [];\n\n\tctrl.currentPanel = 0;\n\tctrl.scrollInterval = 0;\n\tctrl.scrollOffset = 0;\n\tctrl.isSnapping = false;\n\tctrl.enabled = true;\n\n\tctrl.speed = 400;\t\t// default snap animation duration in milliseconds\n\tctrl.threshold = 50;\t// default pixel threshold for snap to occur in pixels\n\tctrl.prevKey = 38;\t\t// default prevKey key code - up arrow\n\tctrl.nextKey = 40;\t\t// default nextKey key code - down arrow\n\n\t/*\n\t * add a panels scope to the panels array\n\t * - attached to `this` so it can be called from child panel directives\n\t */\n\tctrl.addPanel = function (panelScope) {\n\t\tvar panelName = angular.isDefined(panelScope.name) ? panelScope.name : 'Panel ' + (ctrl.panels.length + 1);\n\t\tctrl.panels.push(panelScope);\n\t\tif (angular.isDefined($scope.name)) {\n\t\t\t$rootScope.$emit('panelsnap:addedPanel', { group: $scope.name, name: panelName, id: ctrl.panels.length-1 });\n\t\t}\n\t};\n\n\t/*\n\t * enable snapping\n\t */\n\tctrl.enableSnap = function () {\n\t\t// TODO: should this snap to closest panel when enabled?\n\t\tctrl.enabled = true;\n\t};\n\n\t/*\n\t * disable snapping\n\t */\n\tctrl.disableSnap = function () {\n\t\tctrl.enabled = false;\n\t};\n\n\t/*\n\t * toggle snapping\n\t */\n\tctrl.toggleSnap = function () {\n\t\tctrl.enabled = !ctrl.enabled;\n\t};\n\n\t/*\n\t * initialise the controller state\n\t * - called from the directive link function. This ensures it is called after any child panels\n\t *  link function has called addPanel and therefore the panels array is filled and valid.\n\t */\n\t$scope.init = function () {\n\t\tctrl.container = $element;\n\t\tctrl.eventContainer = ctrl.container;\n\t\tctrl.snapContainer = ctrl.container;\n\n\t\t// if full window, bind and snap using document instead of element\n\t\tif ($scope.fullWindow) {\n\t\t\tctrl.container = angular.element($document[0].documentElement);\n\t\t\tctrl.eventContainer = ctrl.snapContainer = $document;\n\t\t}\n\n\t\t// set options / variables\n\t\tctrl.scrollInterval = isNaN(ctrl.container[0].innerHeight) ? ctrl.container[0].clientHeight : ctrl.container[0].innerHeight;\n\t\tctrl.speed = angular.isDefined($scope.speed) ? $scope.speed : ctrl.speed;\n\t\tctrl.threshold = angular.isDefined($scope.threshold) ? $scope.threshold : ctrl.threshold;\n\t\tctrl.prevKey = angular.isDefined($scope.prevKey) ? $scope.prevKey : ctrl.prevKey;\n\t\tctrl.nextKey = angular.isDefined($scope.nextKey) ? $scope.nextKey : ctrl.nextKey;\n\t\tctrl.currentPanel = angular.isDefined($scope.currentPanel) ? $scope.currentPanel: ctrl.currentPanel;\n\n\t\tbind();\n\t\tactivatePanel(ctrl.currentPanel);\n\t\tsnapToPanel($scope.currentPanel);\n\n\t\t$scope.$watch('currentPanel', function(){\n\t\t\tsnapToPanel($scope.currentPanel);\n\t\t});\n\t};\n\n\t/*\n\t * listen for selectPanel event, if group name matches then snap\n\t * to the target panel\n\t */\n\t$rootScope.$on('panelsnap:selectPanel', function (event, data) {\n\t\tif ($scope.name === data.group) {\n\t\t\tevent.stopPropagation();\n\t\t\tsnapToPanel(data.id);\n\t\t}\n\t});\n\n\tfunction bind() {\n\t\t// bind scrolling events\n\t\tctrl.eventContainer.on('mousewheel scroll touchmove', scrollFn);\n\n\t\t// bind resize event\n\t\tangular.element($window).on('resize', resize);\n\n\t\t// bind keyboard events\n\t\tif ($scope.keyboard) {\n\t\t\tangular.element($window).on('keydown', keydown);\n\t\t}\n\t}\n\n\tfunction keydown(e) {\n\t\tif (!ctrl.enabled) {\n\t\t\treturn;\n\t\t}\n\n\t\t// prevent any keypress events while snapping\n\t\tif (ctrl.isSnapping) {\n\t\t\tif (e.which === ctrl.prevKey || e.which === ctrl.nextKey) {\n\t\t\t\te.preventDefault();\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tswitch (e.which) {\n\t\t\tcase ctrl.prevKey:\n\t\t\t\te.preventDefault();\n\t\t\t\tsnapToPanel(ctrl.currentPanel - 1);\n\t\t\t\tbreak;\n\t\t\tcase ctrl.nextKey:\n\t\t\t\te.preventDefault();\n\t\t\t\tsnapToPanel(ctrl.currentPanel + 1);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tfunction scrollFn(e) {\n\t\tvar threshold = 50;\n\t\t$timeout.cancel(scrollTimeout);\n\t\tscrollTimeout = $timeout(function () {\n\t\t\t//scrollStop(e);\n\t\t}, threshold);\n\t}\n\n\tfunction resize() {\n\t\tvar threshold = 150;\n\t\t$timeout.cancel(resizeTimeout);\n\t\tresizeTimeout = $timeout(function () {\n\t\t\tctrl.scrollInterval = isNaN(ctrl.container[0].innerHeight) ? ctrl.container[0].clientHeight : ctrl.container[0].innerHeight;\n\t\t\t\n\t\t\tif (!ctrl.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// snap back to current panel after resizing\n\t\t\tsnapToPanel(ctrl.currentPanel);\n\t\t}, threshold);\n\t}\n\n\tfunction scrollStop(e) {\n\t\te.stopPropagation();\n\n\t\t// if (ctrl.isMouseDown) {\n\t\t// \treturn;\n\t\t// }\n\n\t\tif (ctrl.isSnapping) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar target;\n\t\tvar offset = ctrl.snapContainer.scrollTop();\n\n\t\tif (!ctrl.enabled) {\n\t\t\t// still want to activate the correct panel even if snapping is disabled\n\t\t\ttarget = Math.max(0, Math.min(Math.round(offset / ctrl.scrollInterval), ctrl.panels.length - 1));\n\t\t\tif (target !== ctrl.currentPanel) {\n\t\t\t\tactivatePanel(target);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tvar scrollDifference = offset - ctrl.scrollOffset;\n\t\tvar maxOffset = ctrl.container[0].scrollHeight - ctrl.scrollInterval;\n\n\t\t// determine target panel\n\t\tif (scrollDifference < -ctrl.threshold && scrollDifference > -ctrl.scrollInterval) {\n\t\t\ttarget = Math.floor(offset / ctrl.scrollInterval);\n\t\t} else if (scrollDifference > ctrl.threshold && scrollDifference < ctrl.scrollInterval) {\n\t\t\ttarget = Math.ceil(offset / ctrl.scrollInterval);\n\t\t} else {\n\t\t\ttarget = Math.round(offset / ctrl.scrollInterval);\n\t\t}\n\n\t\t// ensure target is within panel array bounds\n\t\ttarget = Math.max(0, Math.min(target, ctrl.panels.length - 1));\n\n\t\tif (scrollDifference === 0) {\n\t\t\t// Do nothing\n\t\t} else if (offset <= 0 || offset >= maxOffset) {\n\t\t\t// only activate to prevent stuttering\n\t\t\tactivatePanel(target);\n\t\t\t// set a scrollOffset to a sane number for next scroll\n\t\t\tctrl.scrollOffset = offset <= 0 ? 0 : maxOffset;\n\t\t} else {\n\t\t\tsnapToPanel(target);\n\t\t}\n\t}\n\n\tfunction snapToPanel(target) {\n\t\tif (isNaN(target) || target < 0 || target >= ctrl.panels.length) {\n\t\t\treturn;\n\t\t}\n\n\t\tctrl.isSnapping = true;\n\n\t\t$rootScope.$broadcast('panelsnap:start', { group: $scope.name });\n\t\tctrl.panels[ctrl.currentPanel].onLeave();\n\n\t\tvar scrollTarget = ctrl.scrollInterval * target;\n\t\tctrl.snapContainer.scrollTo(0, scrollTarget, ctrl.speed).then(function () {\n\t\t\tctrl.scrollOffset = scrollTarget;\n\t\t\tctrl.isSnapping = false;\n\n\t\t\t$rootScope.$broadcast('panelsnap:finish', { group: $scope.name });\n\t\t\tctrl.panels[target].onEnter();\n\n\t\t\tactivatePanel(target);\n\t\t});\n\t}\n\n\tfunction activatePanel(target) {\n\t\t// if no panels, or panels have not yet loaded (within ng-repeat) return\n\t\tif (!ctrl.panels || ctrl.panels.length < 1) { \n\t\t\treturn;\n\t\t}\n\n\t\tangular.forEach(ctrl.panels, function (panel) {\n\t\t\tpanel.setActive(false);\n\t\t});\n\t\tctrl.panels[target].setActive(true);\n\t\tctrl.currentPanel = target;\n\t\t$scope.currentPanel = target;\n\n\t\t// TODO: call onActivate function for target\n\t\t$rootScope.$broadcast('panelsnap:activate', {group: $scope.name });\n\t\t$rootScope.$emit('panelsnap:activatePanel', { group: $scope.name, id: target });\n\t}\n}\npanelGroupController.$inject = [\"$scope\", \"$element\", \"$attrs\", \"$window\", \"$timeout\", \"$document\", \"$rootScope\"];\n\n\n})();\n\n(function() {\n'use strict';\n\n/*\n * ak-panel directive\n *\n * Creates a panel inside an ak-panel-group directive. Must be a child of an ak-panel-group element.\n *\n * @attribute name (optional) String: name of panel, will form text of nav element in any ak-panel-group-menu's assocaited with the containing group\n * @attribute onEnter (optional) Function: function to be called when panel is snapped into\n * @attribute onLeave (optional) Function: function to be called when panel is snapped out of\n */\nangular\n\t.module('akreitals.panel-snap')\n\t.directive('akPanel', akPanel);\n\n/* @ngInject */\nfunction akPanel () {\n\treturn {\n\t\trestrict: 'EA',\n\t\trequire: '^akPanelGroup',\n\t\treplace: true,\n\t\ttransclude: true,\n\t\tscope: {\n\t\t\tname: '@',\n\t\t\tonEnter: '&',\n\t\t\tonLeave: '&'\n\t\t},\n\t\ttemplate: '<div class=\"ak-panel\" ng-class=\"{active: active}\" ng-transclude></div>',\n\t\tlink: function (scope, element, attrs, ctrl) {\n\n\t\t\t// add to parent ak-panel-group\n\t\t\tctrl.addPanel(scope);\n\n\t\t\t// default panel styles\n\t\t\telement.css({\n\t\t\t\t'width': '100%',\n\t\t\t\t'height': '100%',\n\t\t\t\t'position': 'relative',\n\t\t\t\t'overflow': 'hidden'\n\t\t\t});\n\n\t\t\t// attach enable/disable scroll methods to scope - need be accessed by $parent due to transclude scope\n\t\t\tscope.enableSnap = ctrl.enableSnap;\n\t\t\tscope.disableSnap = ctrl.disableSnap;\n\t\t\tscope.toggleSnap = ctrl.toggleSnap;\n\n\t\t\t// active flag and getter function, to set class .active on panel\n\t\t\tscope.active = false;\n\t\t\tscope.setActive = function (active) {\n\t\t\t\tscope.active = active;\n\t\t\t};\n\t\t}\n\t};\n}\n\n})();\n\n(function() {\n'use strict';\n\n/*\n * Scroll methods - removes the need for external jQuery or GreenSock libraries\n *\n * Adapted from durated's Angular Scroll module\n * https://github.com/durated/angular-scroll\n */\nangular\n\t.module('akreitals.panel-snap')\n\t.value('scrollEasing', scrollEasing)\n\t.run(runFn)\n\t.factory('polyfill', polyfill)\n\t.factory('requestAnimation', requestAnimation)\n\t.factory('cancelAnimation', cancelAnimation);\n\nfunction scrollEasing (x) {\n\tif(x < 0.5) {\n\t\treturn Math.pow(x*2, 2)/2;\n\t}\n\treturn 1-Math.pow((1-x)*2, 2)/2;\n}\n\n/* @ngInject */\nfunction runFn ($window, $q, cancelAnimation, requestAnimation, scrollEasing) {\n\tvar proto = angular.element.prototype;\n\n\tvar isDocument = function(el) {\n\t\treturn (typeof HTMLDocument !== 'undefined' && el instanceof HTMLDocument) || (el.nodeType && el.nodeType === el.DOCUMENT_NODE);\n\t};\n\n\tvar isElement = function(el) {\n\t\treturn (typeof HTMLElement !== 'undefined' && el instanceof HTMLElement) || (el.nodeType && el.nodeType === el.ELEMENT_NODE);\n\t};\n\n\tvar unwrap = function(el) {\n\t\treturn isElement(el) || isDocument(el) ? el : el[0];\n\t};\n\n\tproto.scrollTo = function(left, top, duration) {\n\t\tvar aliasFn;\n\t\tif(angular.isElement(left)) {\n\t\t\taliasFn = this.scrollToElement;\n\t\t} else if(duration) {\n\t\t\taliasFn = this.scrollToAnimated;\n\t\t}\n\t\tif(aliasFn) {\n\t\t\treturn aliasFn.apply(this, arguments);\n\t\t}\n\t\tvar el = unwrap(this);\n\t\tif(isDocument(el)) {\n\t\t\treturn $window.scrollTo(left, top);\n\t\t}\n\t\tel.scrollLeft = left;\n\t\tel.scrollTop = top;\n\t};\n\n\tproto.scrollToAnimated = function(left, top, duration, easing) {\n\t\tvar scrollAnimation, deferred;\n\t\tif(duration && !easing) {\n\t\t\teasing = scrollEasing;\n\t\t}\n\t\tvar startLeft = this.scrollLeft(),\n\t\t\tstartTop = this.scrollTop(),\n\t\t\tdeltaLeft = Math.round(left - startLeft),\n\t\t\tdeltaTop = Math.round(top - startTop);\n\n\t\tvar startTime = null;\n\t\tvar el = this;\n\n\t\tvar cancelOnEvents = 'scroll mousedown mousewheel touchmove keydown';\n\t\tvar cancelScrollAnimation = function($event) {\n\t\t\tif (!$event || $event.which > 0) {\n\t\t\t\tel.unbind(cancelOnEvents, cancelScrollAnimation);\n\t\t\t\tcancelAnimation(scrollAnimation);\n\t\t\t\tdeferred.reject();\n\t\t\t\tscrollAnimation = null;\n\t\t\t}\n\t\t};\n\n\t\tif(scrollAnimation) {\n\t\t\tcancelScrollAnimation();\n\t\t}\n\t\tdeferred = $q.defer();\n\n\t\tif(!deltaLeft && !deltaTop) {\n\t\t\tdeferred.resolve();\n\t\t\treturn deferred.promise;\n\t\t}\n\n\t\tvar animationStep = function(timestamp) {\n\t\t\tif (startTime === null) {\n\t\t\t\tstartTime = timestamp;\n\t\t\t}\n\n\t\t\tvar progress = timestamp - startTime;\n\t\t\tvar percent = (progress >= duration ? 1 : easing(progress/duration));\n\n\t\t\tel.scrollTo(\n\t\t\t\tstartLeft + Math.ceil(deltaLeft * percent),\n\t\t\t\tstartTop + Math.ceil(deltaTop * percent)\n\t\t\t);\n\t\t\tif(percent < 1) {\n\t\t\t\tscrollAnimation = requestAnimation(animationStep);\n\t\t\t} else {\n\t\t\t\tel.unbind(cancelOnEvents, cancelScrollAnimation);\n\t\t\t\tscrollAnimation = null;\n\t\t\t\tdeferred.resolve();\n\t\t\t}\n\t\t};\n\n\t\t//Fix random mobile safari bug when scrolling to top by hitting status bar\n\t\tel.scrollTo(startLeft, startTop);\n\n\t\t// el.bind(cancelOnEvents, cancelScrollAnimation);\n\n\t\tscrollAnimation = requestAnimation(animationStep);\n\t\treturn deferred.promise;\n\t};\n\n\tproto.scrollToElement = function(target, offset, duration, easing) {\n\t\tvar el = unwrap(this);\n\t\tvar top = this.scrollTop() + unwrap(target).getBoundingClientRect().top - (offset || 0);\n\t\tif(isElement(el)) {\n\t\t\ttop -= el.getBoundingClientRect().top;\n\t\t}\n\t\treturn this.scrollTo(0, top, duration, easing);\n\t};\n\n\tvar overloaders = {\n\t\tscrollLeft: function(value, duration, easing) {\n\t\t\tif(angular.isNumber(value)) {\n\t\t\t\treturn this.scrollTo(value, this.scrollTop(), duration, easing);\n\t\t\t}\n\t\t\tvar el = unwrap(this);\n\t\t\tif(isDocument(el)) {\n\t\t\t\treturn $window.scrollX || document.documentElement.scrollLeft || document.body.scrollLeft;\n\t\t\t}\n\t\t\treturn el.scrollLeft;\n\t\t},\n\t\tscrollTop: function(value, duration, easing) {\n\t\t\tif(angular.isNumber(value)) {\n\t\t\t\treturn this.scrollTo(this.scrollTop(), value, duration, easing);\n\t\t\t}\n\t\t\tvar el = unwrap(this);\n\t\t\tif(isDocument(el)) {\n\t\t\t\treturn $window.scrollY || document.documentElement.scrollTop || document.body.scrollTop;\n\t\t\t}\n\t\t\treturn el.scrollTop;\n\t\t}\n\t};\n\n\t//Add duration and easing functionality to existing jQuery getter/setters\n\tvar overloadScrollPos = function(superFn, overloadFn) {\n\t\treturn function(value, duration) {\n\t\t\tif(duration) {\n\t\t\t\treturn overloadFn.apply(this, arguments);\n\t\t\t}\n\t\t\treturn superFn.apply(this, arguments);\n\t\t};\n\t};\n\n\tfor(var methodName in overloaders) {\n\t\tproto[methodName] = (proto[methodName] ? overloadScrollPos(proto[methodName], overloaders[methodName]) : overloaders[methodName]);\n\t}\n}\nrunFn.$inject = [\"$window\", \"$q\", \"cancelAnimation\", \"requestAnimation\", \"scrollEasing\"];\n\n/* @ngInject */\nfunction polyfill ($window) {\n\tvar vendors = ['webkit', 'moz', 'o', 'ms'];\n\n\treturn function(fnName, fallback) {\n\t\tif($window[fnName]) {\n\t\t\treturn $window[fnName];\n\t\t}\n\t\tvar suffix = fnName.substr(0, 1).toUpperCase() + fnName.substr(1);\n\t\tfor(var key, i = 0; i < vendors.length; i++) {\n\t\t\tkey = vendors[i]+suffix;\n\t\t\tif($window[key]) {\n\t\t\t\treturn $window[key];\n\t\t\t}\n\t\t}\n\t\treturn fallback;\n\t};\n}\npolyfill.$inject = [\"$window\"];\n\n/* @ngInject */\nfunction requestAnimation (polyfill, $timeout) {\n\tvar lastTime = 0;\n\tvar fallback = function(callback) {\n\t\tvar currTime = new Date().getTime();\n\t\tvar timeToCall = Math.max(0, 16 - (currTime - lastTime));\n\t\tvar id = $timeout(function() {\n\t\t\tcallback(currTime + timeToCall);\n\t\t}, timeToCall);\n\t\tlastTime = currTime + timeToCall;\n\t\treturn id;\n\t};\n\n\treturn polyfill('requestAnimationFrame', fallback);\n}\nrequestAnimation.$inject = [\"polyfill\", \"$timeout\"];\n\n/* @ngInject */\nfunction cancelAnimation (polyfill, $timeout) {\n\tvar fallback = function(promise) {\n\t\t$timeout.cancel(promise);\n\t};\n\n\treturn polyfill('cancelAnimationFrame', fallback);\n}\ncancelAnimation.$inject = [\"polyfill\", \"$timeout\"];\n\n})();\n","(function() {\n'use strict';\n\n/*\n * ak-panel-group directive\n *\n * Container for set of 'ak-panel' directives that maintains the panels state and all interactions with the group\n *\n * @attribute name (optional) String: name of the group, to be referenced in ak-panel-group-menu's 'for' attribute\n * @attribute speed (optional) Number: duration in milliseconds to snap to the desired panel, defaults to 400ms\n * @attribute threshold (optional) Number: amount of pixels required to scroll before snapping to the next panel, defults to 50px \n * @attribute fullWindow (optional) Boolean: true if the panels are to fill the full browser window\n * @attribute keyboard (optional) Boolean: true if key presses can be used to navigate panels\n * @attribute prevKey (optional) Number: keyCode of key to navigate to previous panel, defaults to 38 (up arrow)\n * @attribute nextKey (optional) Number: keyCode of key to navigate to next panel, defaults to 40 (down arrow)\n */\nangular\n\t.module('akreitals.panel-snap')\n\t.directive('akPanelGroup', akPanelGroup)\n\t.controller('PanelGroupController', panelGroupController);\n\n/* @ngInject */\nfunction akPanelGroup () {\n\treturn {\n\t\trestrict: 'EA',\n\t\treplace: true,\n\t\tcontroller: 'PanelGroupController',\n\t\tscope: {\n\t\t\tname: '@',\n\t\t\tspeed: '=',\n\t\t\tthreshold: '=',\n\t\t\tfullWindow: '=',\n\t\t\tkeyboard: '=',\n\t\t\tprevKey: '=',\n\t\t\tnextKey: '=',\n\t\t\tcurrentPanel: '='\n\t\t},\n\t\tlink: function (scope) {\n\t\t\t// Call init after child panels have registered with the controller\n\t\t\tscope.init();\n\t\t}\n\t};\n}\n\n/* @ngInject */\nfunction panelGroupController ($scope, $element, $attrs, $window, $timeout, $document, $rootScope) {\n\tvar ctrl = this;\n\n\tvar resizeTimeout;\n\tvar scrollTimeout;\n\n\tctrl.panels = [];\n\n\tctrl.currentPanel = 0;\n\tctrl.scrollInterval = 0;\n\tctrl.scrollOffset = 0;\n\tctrl.isSnapping = false;\n\tctrl.enabled = true;\n\n\tctrl.speed = 400;\t\t// default snap animation duration in milliseconds\n\tctrl.threshold = 50;\t// default pixel threshold for snap to occur in pixels\n\tctrl.prevKey = 38;\t\t// default prevKey key code - up arrow\n\tctrl.nextKey = 40;\t\t// default nextKey key code - down arrow\n\n\t/*\n\t * add a panels scope to the panels array\n\t * - attached to `this` so it can be called from child panel directives\n\t */\n\tctrl.addPanel = function (panelScope) {\n\t\tvar panelName = angular.isDefined(panelScope.name) ? panelScope.name : 'Panel ' + (ctrl.panels.length + 1);\n\t\tctrl.panels.push(panelScope);\n\t\tif (angular.isDefined($scope.name)) {\n\t\t\t$rootScope.$emit('panelsnap:addedPanel', { group: $scope.name, name: panelName, id: ctrl.panels.length-1 });\n\t\t}\n\t};\n\n\t/*\n\t * enable snapping\n\t */\n\tctrl.enableSnap = function () {\n\t\t// TODO: should this snap to closest panel when enabled?\n\t\tctrl.enabled = true;\n\t};\n\n\t/*\n\t * disable snapping\n\t */\n\tctrl.disableSnap = function () {\n\t\tctrl.enabled = false;\n\t};\n\n\t/*\n\t * toggle snapping\n\t */\n\tctrl.toggleSnap = function () {\n\t\tctrl.enabled = !ctrl.enabled;\n\t};\n\n\t/*\n\t * initialise the controller state\n\t * - called from the directive link function. This ensures it is called after any child panels\n\t *  link function has called addPanel and therefore the panels array is filled and valid.\n\t */\n\t$scope.init = function () {\n\t\tctrl.container = $element;\n\t\tctrl.eventContainer = ctrl.container;\n\t\tctrl.snapContainer = ctrl.container;\n\n\t\t// if full window, bind and snap using document instead of element\n\t\tif ($scope.fullWindow) {\n\t\t\tctrl.container = angular.element($document[0].documentElement);\n\t\t\tctrl.eventContainer = ctrl.snapContainer = $document;\n\t\t}\n\n\t\t// set options / variables\n\t\tctrl.scrollInterval = isNaN(ctrl.container[0].innerHeight) ? ctrl.container[0].clientHeight : ctrl.container[0].innerHeight;\n\t\tctrl.speed = angular.isDefined($scope.speed) ? $scope.speed : ctrl.speed;\n\t\tctrl.threshold = angular.isDefined($scope.threshold) ? $scope.threshold : ctrl.threshold;\n\t\tctrl.prevKey = angular.isDefined($scope.prevKey) ? $scope.prevKey : ctrl.prevKey;\n\t\tctrl.nextKey = angular.isDefined($scope.nextKey) ? $scope.nextKey : ctrl.nextKey;\n\t\tctrl.currentPanel = angular.isDefined($scope.currentPanel) ? $scope.currentPanel: ctrl.currentPanel;\n\n\t\tbind();\n\t\tactivatePanel(ctrl.currentPanel);\n\t\tsnapToPanel($scope.currentPanel);\n\n\t\t$scope.$watch('currentPanel', function(){\n\t\t\tsnapToPanel($scope.currentPanel);\n\t\t});\n\t};\n\n\t/*\n\t * listen for selectPanel event, if group name matches then snap\n\t * to the target panel\n\t */\n\t$rootScope.$on('panelsnap:selectPanel', function (event, data) {\n\t\tif ($scope.name === data.group) {\n\t\t\tevent.stopPropagation();\n\t\t\tsnapToPanel(data.id);\n\t\t}\n\t});\n\n\tfunction bind() {\n\t\t// bind scrolling events\n\t\tctrl.eventContainer.on('mousewheel scroll touchmove', scrollFn);\n\n\t\t// bind resize event\n\t\tangular.element($window).on('resize', resize);\n\n\t\t// bind keyboard events\n\t\tif ($scope.keyboard) {\n\t\t\tangular.element($window).on('keydown', keydown);\n\t\t}\n\t}\n\n\tfunction keydown(e) {\n\t\tif (!ctrl.enabled) {\n\t\t\treturn;\n\t\t}\n\n\t\t// prevent any keypress events while snapping\n\t\tif (ctrl.isSnapping) {\n\t\t\tif (e.which === ctrl.prevKey || e.which === ctrl.nextKey) {\n\t\t\t\te.preventDefault();\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tswitch (e.which) {\n\t\t\tcase ctrl.prevKey:\n\t\t\t\te.preventDefault();\n\t\t\t\tsnapToPanel(ctrl.currentPanel - 1);\n\t\t\t\tbreak;\n\t\t\tcase ctrl.nextKey:\n\t\t\t\te.preventDefault();\n\t\t\t\tsnapToPanel(ctrl.currentPanel + 1);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tfunction scrollFn(e) {\n\t\tvar threshold = 50;\n\t\t$timeout.cancel(scrollTimeout);\n\t\tscrollTimeout = $timeout(function () {\n\t\t\t//scrollStop(e);\n\t\t}, threshold);\n\t}\n\n\tfunction resize() {\n\t\tvar threshold = 150;\n\t\t$timeout.cancel(resizeTimeout);\n\t\tresizeTimeout = $timeout(function () {\n\t\t\tctrl.scrollInterval = isNaN(ctrl.container[0].innerHeight) ? ctrl.container[0].clientHeight : ctrl.container[0].innerHeight;\n\t\t\t\n\t\t\tif (!ctrl.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// snap back to current panel after resizing\n\t\t\tsnapToPanel(ctrl.currentPanel);\n\t\t}, threshold);\n\t}\n\n\tfunction scrollStop(e) {\n\t\te.stopPropagation();\n\n\t\t// if (ctrl.isMouseDown) {\n\t\t// \treturn;\n\t\t// }\n\n\t\tif (ctrl.isSnapping) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar target;\n\t\tvar offset = ctrl.snapContainer.scrollTop();\n\n\t\tif (!ctrl.enabled) {\n\t\t\t// still want to activate the correct panel even if snapping is disabled\n\t\t\ttarget = Math.max(0, Math.min(Math.round(offset / ctrl.scrollInterval), ctrl.panels.length - 1));\n\t\t\tif (target !== ctrl.currentPanel) {\n\t\t\t\tactivatePanel(target);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tvar scrollDifference = offset - ctrl.scrollOffset;\n\t\tvar maxOffset = ctrl.container[0].scrollHeight - ctrl.scrollInterval;\n\n\t\t// determine target panel\n\t\tif (scrollDifference < -ctrl.threshold && scrollDifference > -ctrl.scrollInterval) {\n\t\t\ttarget = Math.floor(offset / ctrl.scrollInterval);\n\t\t} else if (scrollDifference > ctrl.threshold && scrollDifference < ctrl.scrollInterval) {\n\t\t\ttarget = Math.ceil(offset / ctrl.scrollInterval);\n\t\t} else {\n\t\t\ttarget = Math.round(offset / ctrl.scrollInterval);\n\t\t}\n\n\t\t// ensure target is within panel array bounds\n\t\ttarget = Math.max(0, Math.min(target, ctrl.panels.length - 1));\n\n\t\tif (scrollDifference === 0) {\n\t\t\t// Do nothing\n\t\t} else if (offset <= 0 || offset >= maxOffset) {\n\t\t\t// only activate to prevent stuttering\n\t\t\tactivatePanel(target);\n\t\t\t// set a scrollOffset to a sane number for next scroll\n\t\t\tctrl.scrollOffset = offset <= 0 ? 0 : maxOffset;\n\t\t} else {\n\t\t\tsnapToPanel(target);\n\t\t}\n\t}\n\n\tfunction snapToPanel(target) {\n\t\tif (isNaN(target) || target < 0 || target >= ctrl.panels.length) {\n\t\t\treturn;\n\t\t}\n\n\t\tctrl.isSnapping = true;\n\n\t\t$rootScope.$broadcast('panelsnap:start', { group: $scope.name });\n\t\tctrl.panels[ctrl.currentPanel].onLeave();\n\n\t\tvar scrollTarget = ctrl.scrollInterval * target;\n\t\tctrl.snapContainer.scrollTo(0, scrollTarget, ctrl.speed).then(function () {\n\t\t\tctrl.scrollOffset = scrollTarget;\n\t\t\tctrl.isSnapping = false;\n\n\t\t\t$rootScope.$broadcast('panelsnap:finish', { group: $scope.name });\n\t\t\tctrl.panels[target].onEnter();\n\n\t\t\tactivatePanel(target);\n\t\t});\n\t}\n\n\tfunction activatePanel(target) {\n\t\t// if no panels, or panels have not yet loaded (within ng-repeat) return\n\t\tif (!ctrl.panels || ctrl.panels.length < 1) { \n\t\t\treturn;\n\t\t}\n\n\t\tangular.forEach(ctrl.panels, function (panel) {\n\t\t\tpanel.setActive(false);\n\t\t});\n\t\tctrl.panels[target].setActive(true);\n\t\tctrl.currentPanel = target;\n\t\t$scope.currentPanel = target;\n\n\t\t// TODO: call onActivate function for target\n\t\t$rootScope.$broadcast('panelsnap:activate', {group: $scope.name });\n\t\t$rootScope.$emit('panelsnap:activatePanel', { group: $scope.name, id: target });\n\t}\n}\n\n\n})();\n","(function() {\n'use strict';\n\n/*\n * ak-panel directive\n *\n * Creates a panel inside an ak-panel-group directive. Must be a child of an ak-panel-group element.\n *\n * @attribute name (optional) String: name of panel, will form text of nav element in any ak-panel-group-menu's assocaited with the containing group\n * @attribute onEnter (optional) Function: function to be called when panel is snapped into\n * @attribute onLeave (optional) Function: function to be called when panel is snapped out of\n */\nangular\n\t.module('akreitals.panel-snap')\n\t.directive('akPanel', akPanel);\n\n/* @ngInject */\nfunction akPanel () {\n\treturn {\n\t\trestrict: 'EA',\n\t\trequire: '^akPanelGroup',\n\t\treplace: true,\n\t\ttransclude: true,\n\t\tscope: {\n\t\t\tname: '@',\n\t\t\tonEnter: '&',\n\t\t\tonLeave: '&'\n\t\t},\n\t\ttemplate: '<div class=\"ak-panel\" ng-class=\"{active: active}\" ng-transclude></div>',\n\t\tlink: function (scope, element, attrs, ctrl) {\n\n\t\t\t// add to parent ak-panel-group\n\t\t\tctrl.addPanel(scope);\n\n\t\t\t// default panel styles\n\t\t\telement.css({\n\t\t\t\t'width': '100%',\n\t\t\t\t'height': '100%',\n\t\t\t\t'position': 'relative',\n\t\t\t\t'overflow': 'hidden'\n\t\t\t});\n\n\t\t\t// attach enable/disable scroll methods to scope - need be accessed by $parent due to transclude scope\n\t\t\tscope.enableSnap = ctrl.enableSnap;\n\t\t\tscope.disableSnap = ctrl.disableSnap;\n\t\t\tscope.toggleSnap = ctrl.toggleSnap;\n\n\t\t\t// active flag and getter function, to set class .active on panel\n\t\t\tscope.active = false;\n\t\t\tscope.setActive = function (active) {\n\t\t\t\tscope.active = active;\n\t\t\t};\n\t\t}\n\t};\n}\n\n})();\n","(function() {\n'use strict';\n\n/*\n * Scroll methods - removes the need for external jQuery or GreenSock libraries\n *\n * Adapted from durated's Angular Scroll module\n * https://github.com/durated/angular-scroll\n */\nangular\n\t.module('akreitals.panel-snap')\n\t.value('scrollEasing', scrollEasing)\n\t.run(runFn)\n\t.factory('polyfill', polyfill)\n\t.factory('requestAnimation', requestAnimation)\n\t.factory('cancelAnimation', cancelAnimation);\n\nfunction scrollEasing (x) {\n\tif(x < 0.5) {\n\t\treturn Math.pow(x*2, 2)/2;\n\t}\n\treturn 1-Math.pow((1-x)*2, 2)/2;\n}\n\n/* @ngInject */\nfunction runFn ($window, $q, cancelAnimation, requestAnimation, scrollEasing) {\n\tvar proto = angular.element.prototype;\n\n\tvar isDocument = function(el) {\n\t\treturn (typeof HTMLDocument !== 'undefined' && el instanceof HTMLDocument) || (el.nodeType && el.nodeType === el.DOCUMENT_NODE);\n\t};\n\n\tvar isElement = function(el) {\n\t\treturn (typeof HTMLElement !== 'undefined' && el instanceof HTMLElement) || (el.nodeType && el.nodeType === el.ELEMENT_NODE);\n\t};\n\n\tvar unwrap = function(el) {\n\t\treturn isElement(el) || isDocument(el) ? el : el[0];\n\t};\n\n\tproto.scrollTo = function(left, top, duration) {\n\t\tvar aliasFn;\n\t\tif(angular.isElement(left)) {\n\t\t\taliasFn = this.scrollToElement;\n\t\t} else if(duration) {\n\t\t\taliasFn = this.scrollToAnimated;\n\t\t}\n\t\tif(aliasFn) {\n\t\t\treturn aliasFn.apply(this, arguments);\n\t\t}\n\t\tvar el = unwrap(this);\n\t\tif(isDocument(el)) {\n\t\t\treturn $window.scrollTo(left, top);\n\t\t}\n\t\tel.scrollLeft = left;\n\t\tel.scrollTop = top;\n\t};\n\n\tproto.scrollToAnimated = function(left, top, duration, easing) {\n\t\tvar scrollAnimation, deferred;\n\t\tif(duration && !easing) {\n\t\t\teasing = scrollEasing;\n\t\t}\n\t\tvar startLeft = this.scrollLeft(),\n\t\t\tstartTop = this.scrollTop(),\n\t\t\tdeltaLeft = Math.round(left - startLeft),\n\t\t\tdeltaTop = Math.round(top - startTop);\n\n\t\tvar startTime = null;\n\t\tvar el = this;\n\n\t\tvar cancelOnEvents = 'scroll mousedown mousewheel touchmove keydown';\n\t\tvar cancelScrollAnimation = function($event) {\n\t\t\tif (!$event || $event.which > 0) {\n\t\t\t\tel.unbind(cancelOnEvents, cancelScrollAnimation);\n\t\t\t\tcancelAnimation(scrollAnimation);\n\t\t\t\tdeferred.reject();\n\t\t\t\tscrollAnimation = null;\n\t\t\t}\n\t\t};\n\n\t\tif(scrollAnimation) {\n\t\t\tcancelScrollAnimation();\n\t\t}\n\t\tdeferred = $q.defer();\n\n\t\tif(!deltaLeft && !deltaTop) {\n\t\t\tdeferred.resolve();\n\t\t\treturn deferred.promise;\n\t\t}\n\n\t\tvar animationStep = function(timestamp) {\n\t\t\tif (startTime === null) {\n\t\t\t\tstartTime = timestamp;\n\t\t\t}\n\n\t\t\tvar progress = timestamp - startTime;\n\t\t\tvar percent = (progress >= duration ? 1 : easing(progress/duration));\n\n\t\t\tel.scrollTo(\n\t\t\t\tstartLeft + Math.ceil(deltaLeft * percent),\n\t\t\t\tstartTop + Math.ceil(deltaTop * percent)\n\t\t\t);\n\t\t\tif(percent < 1) {\n\t\t\t\tscrollAnimation = requestAnimation(animationStep);\n\t\t\t} else {\n\t\t\t\tel.unbind(cancelOnEvents, cancelScrollAnimation);\n\t\t\t\tscrollAnimation = null;\n\t\t\t\tdeferred.resolve();\n\t\t\t}\n\t\t};\n\n\t\t//Fix random mobile safari bug when scrolling to top by hitting status bar\n\t\tel.scrollTo(startLeft, startTop);\n\n\t\t// el.bind(cancelOnEvents, cancelScrollAnimation);\n\n\t\tscrollAnimation = requestAnimation(animationStep);\n\t\treturn deferred.promise;\n\t};\n\n\tproto.scrollToElement = function(target, offset, duration, easing) {\n\t\tvar el = unwrap(this);\n\t\tvar top = this.scrollTop() + unwrap(target).getBoundingClientRect().top - (offset || 0);\n\t\tif(isElement(el)) {\n\t\t\ttop -= el.getBoundingClientRect().top;\n\t\t}\n\t\treturn this.scrollTo(0, top, duration, easing);\n\t};\n\n\tvar overloaders = {\n\t\tscrollLeft: function(value, duration, easing) {\n\t\t\tif(angular.isNumber(value)) {\n\t\t\t\treturn this.scrollTo(value, this.scrollTop(), duration, easing);\n\t\t\t}\n\t\t\tvar el = unwrap(this);\n\t\t\tif(isDocument(el)) {\n\t\t\t\treturn $window.scrollX || document.documentElement.scrollLeft || document.body.scrollLeft;\n\t\t\t}\n\t\t\treturn el.scrollLeft;\n\t\t},\n\t\tscrollTop: function(value, duration, easing) {\n\t\t\tif(angular.isNumber(value)) {\n\t\t\t\treturn this.scrollTo(this.scrollTop(), value, duration, easing);\n\t\t\t}\n\t\t\tvar el = unwrap(this);\n\t\t\tif(isDocument(el)) {\n\t\t\t\treturn $window.scrollY || document.documentElement.scrollTop || document.body.scrollTop;\n\t\t\t}\n\t\t\treturn el.scrollTop;\n\t\t}\n\t};\n\n\t//Add duration and easing functionality to existing jQuery getter/setters\n\tvar overloadScrollPos = function(superFn, overloadFn) {\n\t\treturn function(value, duration) {\n\t\t\tif(duration) {\n\t\t\t\treturn overloadFn.apply(this, arguments);\n\t\t\t}\n\t\t\treturn superFn.apply(this, arguments);\n\t\t};\n\t};\n\n\tfor(var methodName in overloaders) {\n\t\tproto[methodName] = (proto[methodName] ? overloadScrollPos(proto[methodName], overloaders[methodName]) : overloaders[methodName]);\n\t}\n}\n\n/* @ngInject */\nfunction polyfill ($window) {\n\tvar vendors = ['webkit', 'moz', 'o', 'ms'];\n\n\treturn function(fnName, fallback) {\n\t\tif($window[fnName]) {\n\t\t\treturn $window[fnName];\n\t\t}\n\t\tvar suffix = fnName.substr(0, 1).toUpperCase() + fnName.substr(1);\n\t\tfor(var key, i = 0; i < vendors.length; i++) {\n\t\t\tkey = vendors[i]+suffix;\n\t\t\tif($window[key]) {\n\t\t\t\treturn $window[key];\n\t\t\t}\n\t\t}\n\t\treturn fallback;\n\t};\n}\n\n/* @ngInject */\nfunction requestAnimation (polyfill, $timeout) {\n\tvar lastTime = 0;\n\tvar fallback = function(callback) {\n\t\tvar currTime = new Date().getTime();\n\t\tvar timeToCall = Math.max(0, 16 - (currTime - lastTime));\n\t\tvar id = $timeout(function() {\n\t\t\tcallback(currTime + timeToCall);\n\t\t}, timeToCall);\n\t\tlastTime = currTime + timeToCall;\n\t\treturn id;\n\t};\n\n\treturn polyfill('requestAnimationFrame', fallback);\n}\n\n/* @ngInject */\nfunction cancelAnimation (polyfill, $timeout) {\n\tvar fallback = function(promise) {\n\t\t$timeout.cancel(promise);\n\t};\n\n\treturn polyfill('cancelAnimationFrame', fallback);\n}\n\n})();\n"],"sourceRoot":"/source/"}